+++
title = "HAL层接口开发"
+++
# HAL层接口开发

Tags: 技术
Created: March 2, 2022
Last edited: February 2, 2023 2:24 PM
作者: yang
分组: 安卓

## 创建HAL接口

1，生成HAL的存储目录
mkdir -p hardware/interfaces/demo/1.0/default
touch hardware/interface/demo/1.0/IGpio.hal
2, 定义HAL接口 (注意文件名规范，I开头)
HAL 语法：[https://source.android.com/devices/architecture/hidl/code-style](https://source.android.com/devices/architecture/hidl/code-style)

```bash
package vendor.tcl.gpio@1.0;

interface IGpio {
    setGPIO(int32_t index, int32_t value, int32_t direction) generates(bool result);
};
```

### **hidl-gen工具**

Google帮我们提供了一些工具来生成HAL层相关的代码框架和代码实例，这样子我们只需要关心实现部分，而不需要写一堆无用代码，浪费时间在搞Makefile和一些低级错误上。**hidl-gen工具需要编译生成。**

在根目录运行： 
`source build/envsetup.sh
lunch
make hidl-gen`          

生成的hidl-gen工具位于out/host/linux-x86/bin/hidl-gen （Android 9）

### 生成HAL相关文件

```bash
PACKAGE=android.hardware.hidl_daemon@1.0
LOC=hardware/interfaces/hidl_daemon/1.0/default/
hidl-gen -o $LOC -Lc++-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE
hidl-gen -o $LOC -Landroidbp-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE
hidl-gen -L hash -rvendor.tcl:vendor/tcl/hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE
```

如果报错 `ERROR: Package root not specified for vendor.tcl.gpio@1.0`  是需要更新hash值到cd current.txt中，语句参考上面的hidl-gen -L hash

上个部分将自动生成cpp,h,bp文件。最终得到的文件目录为：

```bash
├── 1.0
│   ├── Android.bp
│   ├── default
│   │   ├── Android.bp
│   │   ├── Gpio.cpp
│   │   ├── Gpio.h
│   └── IGpio.hal
├── Android.bp
├── current.txt
└── genImpHidl.sh
```

### 修改cpp和h文件

Gpio.h

```bash
#ifndef VENDOR_TCL_GPIO_V1_0_GPIO_H
#define VENDOR_TCL_GPIO_V1_0_GPIO_H

#include <vendor/tcl/gpio/1.0/IGpio.h>
#include <hidl/MQDescriptor.h>
#include <hidl/Status.h>

namespace vendor {
namespace tcl {
namespace gpio {
namespace V1_0 {
namespace implementation {

using ::android::hardware::hidl_array;
using ::android::hardware::hidl_memory;
using ::android::hardware::hidl_string;
using ::android::hardware::hidl_vec;
using ::android::hardware::Return;
using ::android::hardware::Void;
using ::android::sp;

struct Gpio : public IGpio {
public:
    Gpio();
    // Methods from ::vendor::tcl::gpio::V1_0::IGpio follow.
    Return<bool> setGPIO(int32_t index, int32_t value, int32_t direction) override;

    // Methods from ::android::hidl::base::V1_0::IBase follow.

};

// FIXME: most likely delete, this is only for passthrough implementations
// extern "C" IGpio* HIDL_FETCH_IGpio(const char* name);

}  // namespace implementation
}  // namespace V1_0
}  // namespace gpio
}  // namespace tcl
}  // namespace vendor

#endif  // VENDOR_TCL_GPIO_V1_0_GPIO_H
```

Gpio.cpp

```bash
#include "Gpio.h"
#include <iostream>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/stat.h>
#include <android/log.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <stdlib.h>
#include<stdio.h>
#include <cutils/properties.h>

//#include "./hal/include/fpp/fpp_iic_gpio.h"

namespace vendor {
namespace tcl {
namespace gpio {
namespace V1_0 {
namespace implementation {

// Methods from ::vendor::tcl::gpio::V1_0::IGpio follow.
Return<bool> Gpio::setGPIO(int32_t index, int32_t value, int32_t direction) {
    // TODO implement
    int status = -1;
    std::string gpio_index = std::to_string(index);
    std::string gpio_value = std::to_string(value);
    if(direction > 0){
        std::string gpio_direction = "out";
    } 
    else {
        std::string gpio_direction = "in";
    }
    std::string cmd = "echo "+gpio_index+"> /sys/class/gpio/export";
    status = system(cmd.c_str()); 
    cmd = "echo " + gpio_direction + " > /sys/class/gpio/gpio" + gpio_index + "/direction";
    status = system(cmd.c_str());
    cmd = "echo "+gpio_value+" > /sys/class/gpio/gpio"+gpio_index+"/value";
    status = system(cmd.c_str());
    if(status == -1) 
        return 1;
    else
        return 0;
}

Gpio::Gpio(){
    printf("gpio control init.-- yang");
/*    fpi_error ret = FPI_ERROR_GPIO_FAIL;
    EN_FPP_GPIO_INDEX_T gpio_index = EN_FPP_GPIO_INDEX_RS232_IR;
    ST_FPP_GPIO_CONFIG_T pin_config;
    pin_config.direction = EN_FPP_GPIO_DIRECTION_OUTPUT;
    pin_config.interrupt_mode = EN_FPP_GPIO_INT_DISABLED;
    pin_config.Callback = NULL;
    ret = fpp_gpio_configure(gpio_index, &pin_config);
    printf("%s, ret = %d",__FUNCTION__, ret);
*/
   int status;
   status = system("echo 482 > /sys/class/gpio/export");
   if(status == -1){
       printf("echo 482 error");
   }
   else {
       status = system("echo out > /sys/class/gpio/gpio482/direction");
       if(status == -1){ printf("echo 482 direction error");}
       status = system("echo 0 > /sys/class/gpio/gpio482/value");
       if(status == -1){ printf("echo 482 value error");}
   }
   char prop[PROP_VALUE_MAX] = "00";
   property_get("persist.tcl.rs232ir.switch", prop, NULL);
   if(prop[0] == '0') {
       system("echo 0 > /sys/class/gpio/gpio482/value");
    }
    else if(prop[0] == '1'){
        system("echo 1 > /sys/class/gpio/gpio482/value");
    }
}
// Methods from ::android::hidl::base::V1_0::IBase follow.

//IGpio* HIDL_FETCH_IGpio(const char* /* name */) {
    //return new Gpio();
//}
//
}  // namespace implementation
}  // namespace V1_0
}  // namespace gpio
}  // namespace tcl
}  // namespace vendor
```

### 添加启动 service

default文件夹下，增加 vendor.tcl.gpio@1.0-service.rc启动脚本

```bash
service hal_gpio_service /vendor/bin/hw/vendor.tcl.gpio@1.0-service
    class hal
    user system
    group root
```

新建service.cpp

```bash
#define LOG_TAG "vendor.tcl.gpio@1.0-service"

#include <vendor/tcl/gpio/1.0/IGpio.h>
#include <hidl/HidlTransportSupport.h>
#include <log/log.h>
#include <utils/StrongPointer.h>
#include "Gpio.h"

using android::hardware::configureRpcThreadpool;
using android::hardware::joinRpcThreadpool;
using vendor::tcl::gpio::V1_0::IGpio;
using vendor::tcl::gpio::implementation::Gpio;

int main(int /* argc */, char** /* argv */) {

    configureRpcThreadpool(1, true);  //配置线程池

    android::sp<IGpio> gpio = new Gpio();   //获取gpio强指针
    if (gpio->registerAsService() != ::android::OK) {  //注册服务
        ALOGE("Failed to register gpio control HAL instance");
        return -1;
    }

    joinRpcThreadpool();  //加入线程池
    return 1;  // joinRpcThreadpool shouldn't exit
}
```

修改Android.bp

```bash
cc_binary {
    // FIXME: this should only be -impl for a passthrough hal.
    // In most cases, to convert this to a binderized implementation, you should:
    // - change '-impl' to '-service' here and make it a cc_binary instead of a
    //   cc_library_shared.
    // - add a *.rc file for this module.
    // - delete HIDL_FETCH_I* functions.
    // - call configureRpcThreadpool and registerAsService on the instance.
    // You may also want to append '-impl/-service' with a specific identifier like
    // '-vendor' or '-<hardware identifier>' etc to distinguish it.
    name: "vendor.tcl.gpio@1.0-service",
    defaults: ["hidl_defaults"],
    vendor: true,
    relative_install_path: "hw",
    init_rc: ["vendor.tcl.gpio@1.0-service.rc"],
    // FIXME: this should be 'vendor: true' for modules that will eventually be
    // on AOSP.
    //proprietary: true,
    srcs: [
        "Gpio.cpp",
        "service.cpp",
    ],
    shared_libs: [
        "libhidlbase",
        "libhidltransport",
        "libutils",
        "liblog",
        "libcutils",
        "libhardware",
        "vendor.tcl.gpio@1.0",
    ],
}
```

增加 vendor.tcl.gpio@1.0.xml

```bash
<manifest version="1.0" type="device">
    <hal format="hidl">
        <name>vendor.tcl.gpio</name>
        <transport>hwbinder</transport>
        <version>1.0</version>
        <interface>
            <name>IGpio</name>
            <instance>default</instance>
        </interface>
    </hal>
</manifest>
```

### 编译

mmm对应文件夹进行编译，编译完成后会自动生成service及其so库，并在./out/soong/.intermediates/vendor/tcl/hardware/interfaces/gpio/1.0/路径下生成应用层可调用的接口文件 ：

```bash
./out/target/product/ak30a5/vendor/lib/vendor.tcl.gpio@1.0.so   
./out/soong/.intermediates/vendor/tcl/hardware/interfaces/gpio/1.0/
 vendor.tcl.gpio@1.0
 vendor.tcl.gpio@1.0-adapter
 vendor.tcl.gpio@1.0-adapter_genc++
 vendor.tcl.gpio@1.0-adapter-helper
 vendor.tcl.gpio@1.0-adapter-helper_genc++
 vendor.tcl.gpio@1.0-adapter-helper_genc++_headers
 vendor.tcl.gpio@1.0_genc++
 vendor.tcl.gpio@1.0_genc++_headers
 vendor.tcl.gpio-V1.0-java
 vendor.tcl.gpio-V1.0-java_gen_java
```

其中 vendor.tcl.gpio-V1.0-java\android_common\combined 文件夹下vendor.tcl.gpio-V1.0-java.jar

## 添加selinux 权限

**（！！注意：以下是system selinux配置示例，便于理解selinux权限配置的结构。实际新接口service一般在vendor目录下进行配置，作为设备商修改请跳转vendor selinux配置）**

通过**init** 启动的服务需要在各自的 **SELinux**域中运行。为了让**service**能在开机运行，需要配置seLinux权限。selinux配置文件位于 system/sepolicy

### 创建新域

在system/sepolicy/vendor目录下，创建**hal_gpio_default.te**

```bash
type hal_gpio_default, domain;
hal_server_domain(hal_gpio_default, hal_gpio)

type hal_gpio_default_exec, exec_type, vendor_file_type, file_type;
init_daemon_domain(hal_gpio_default)
allow hal_gpio_default gpio_device:chr_file rw_file_perms;
```

**为/vendor/bin/hw/vendor.tcl.led@1.0-service添加标签**

在**system/sepolicy/vendor/file_contexts**添加:

`/(vendor|system/vendor)/bin/hw/vendor\.tcl\.gpio@1\.0-service u:object_r:hal_gpio_default_exec:s0`

### **配置HAL SE Linux权限**

为了使服务能够注册成功，还需要配置**HAL**相关的**SeLinux。**  

在**system/sepolicy/public/attributes**文件中，需要定义**HAL**的名称：

```bash
hal_attribute(gpio);
```

**为HAL创建需要的规则。首先**在文件**system/sepolicy/public/hwservice.te**中添加：

`type hal_gpio_hwservice, hwservice_manager_type;`

然后，在目录**system/sepolicy/public**目录下创建**hal_gpio.te** 来定义详细规则**:**

```bash
# HwBinder IPC from client to server, and callbacks
binder_call(hal_gpio_client, hal_gpio_server)
binder_call(hal_gpio_server, hal_gpio_client)
add_hwservice(hal_gpio_server, hal_gpio_hwservice)
allow hal_gpio_client hal_gpio_hwservice:hwservice_manager find;
```

然后将**system/sepolicy/public**目录下的**attributes、hwservice.te**和**hal_gpio.te**覆盖拷贝到**system/sepolicy/prebuilts/api/28.0/public**目录下。

在**system/sepolicy/private/hwservice_contexts**文件中添加：

`vendor.tcl.gpio::IGpio    u:object_r:hal_gpio_hwservice:s0`

在 **system/sepolicy/private/compat/26.0/26.0.ignore.cil**
和  **system/sepolicy/private/compat/27.0/27.0.ignore.cil**  中加入：`hal_gpio_hwservice`

将上述的private 下修改同步到**system/sepolicy/prebuilts/api/28.0/private**中

## **vendor selinux配置**

963vendor HAL配置 路径在  device/amlogic/common/tcl/sepolicy/ 。需要修改的文件有以下几个：

file_contexts

```bash
/(vendor|system/vendor)/bin/hw/vendor\.tcl\.gpio@1\.0-service          u:object_r:hal_gpio_default_exec:s0
```

新建 hal_gpio_default.te

```bash
type hal_gpio_default, domain;
type hal_gpio_default_exec, exec_type, vendor_file_type, file_type;
init_daemon_domain(hal_gpio_default)
#domain_auto_trans(hal_gpio_default, shell_exec, shell)

binder_call(system_app, hal_gpio_default)
allow system_app hal_gpio_service:hwservice_manager find;

hwbinder_use(hal_gpio_default)
add_hwservice(hal_gpio_default, hal_gpio_service);
get_prop(hal_gpio_default, hwservicemanager_prop)

allow hal_gpio_default sysfs:file rw_file_perms;
allow hal_gpio_default sysfs:dir  r_file_perms;

allow hal_gpio_default proc:file rw_file_perms;
allow hal_gpio_default proc:dir  r_file_perms;

allow hal_gpio_default device:file rw_file_perms;
allow hal_gpio_default device:dir  r_file_perms;

allow hal_gpio_default shell_exec:file { execute read open };
allow hal_gpio_default shell_exec:file { execute_no_trans };
allow hal_gpio_default shell_exec:file { getattr };

#allow hal_gpio_default hwservicemanager_prop:file { read open  getattr setattr append };
#allow hal_gpio_default gpio_device:chr_file { open read write ioctl };
```

hwservice.te

```bash
type hal_gpio_service,      hwservice_manager_type;
```

hwservice_contexts

```bash
#yang87.zhang@tcl.com,2022/2/25,add for gpio set hidl
vendor.tcl.gpio::IGpio                     u:object_r:hal_gpio_service:s0
```

system_server.te

```bash
#gpio service
#allow system_server gpio_service:service_manager { add find };
allow system_server hal_gpio_service:hwservice_manager find;
#allow system_server hal_gpio_default:binder call;
```

device/amlogic / common/core_amlogic.mk文件中增加

```bash

PRODUCT_PACKAGES += \
    vendor.tcl.gpio@1.0 \
    vendor.tcl.gpio@1.0-service
```

### selinux问题处理  avc: denied

解决原则：缺什么权限补什么，直到没有avc denied为止。

解决方法：在对应的.te中增加allow语句。

格式示例：`avc: denied { 操作权限 } for pid=7201 comm=“进程名” scontext=u:r:源[类型](https://so.csdn.net/so/search?q=%E7%B1%BB%E5%9E%8B&spm=1001.2101.3001.7020)
:s0 tcontext=u:r:目标类型:s0 tclass=访问类型 permissive=0`

案例：

audit: type=1400 audit(1113.763:288): avc:  denied  { write } for  pid=328 comm="fastbootd" name="mmcblk0p29" dev="tmpfs" ino=7915 scontext=u:r:fastbootd:s0 tcontext=u:object_r:mmcblk_device:s0 tclass=blk_file permissive=1

scontext和tcontext都是安全上下文，分别称为主体和客体，主体一般都是进程，客体则是主体访问的资源。

缺少什么权限：               { write }权限，

谁缺少权限：                    scontext=u:r:fastbootd:s0

对哪个资源缺少权限：     tcontext=u:object_r:mmcblk_device:s0

什么类型的资源：            tclass=blk_file

完整的意思： fastbootd进程对mmcblk_device类型的blk_file缺少write权限。

解决方法：在fastbootd.te文件（若没有则添加）加入内容：

```
 allow fastbootd mmcblk_device:blk_file { read write getattr open ioctl }; 
#即允许fastbootd对mmcblk_device类型的blk_file进行read/write/ioctl等操作。
#针对dir缺少的任何权限，建议赋予create_dir_perms，基本涵盖对dir的所有权限，比如：
#{ open search write read rename create rmdir getattr }等等。
#针对file缺少的任何权限，建议赋予rwx_file_perms，基本涵盖对file的所有权限，比如：
#包含{ open read write open execute getattr create ioctl }等等。

```

## 配置清单

正常来说还需要在manifest.xml中配置设备清单，但是在此次963G90E的开发中没有进行这一部分修改，也可以正常启动service，未知原因。

## 应用层调用

`setprop persist.tcl.debug.installapk 1`  解除pm install 安装限制

调试

`dumpsys activity services | grep DemoService`

关闭selinux     `setenforce 0`

 启动service  `/vendor/bin/hw/android.hardware.hello@1.0-service&`

# 参考

**[Android SELinux avc denied解决](https://blog.csdn.net/wuzoujing/article/details/89562505)**