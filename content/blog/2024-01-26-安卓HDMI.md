+++
title = "安卓HDMI"
+++
# 安卓HDMI CEC逐层梳理

Tags: 技术
Last edited: June 18, 2023 10:07 AM
作者: yang

[cec开发](%E5%AE%89%E5%8D%93HDMI%20CEC%E9%80%90%E5%B1%82%E6%A2%B3%E7%90%86%208a85a9c2d0264f9fa64d1ff8a7bba967/cec%E5%BC%80%E5%8F%91%20bddd5598987146de9b86e1f70dfe5146.md) 

### 什么是cec？

CEC（Consumer Electronics Control）是一套通信协议（单总线）协议。电子设备可以借着CEC信号让使用可控制HDMI接口上所连接的装置，比如单键播放（One Touth Play）,系统待机（System Standby），可以实现由单一遥控器控制所有HDMI连接的装置。最多可以控制15个设备。允许HDMI设备在没有用户干扰情况下互相命令控制。

简单来说就是通过HDMI连接的设备之间可以按照CEC的规则互相发送信息和命令。

CEC的常见功能：

1. 单键播放(One Touch Play)。当设备开始播放时，允许设备把电视机的输入源切换到该设备
2. 系统待机(System Standby)。当 HDMI 播放设备唤醒时，它会尝试唤醒已连接的电视，并通过 HDMI CEC 单键播放功能成为当前活跃来源。如果作为当前活跃来源的设备进入休眠状态，就会尝试关闭连接的电视。
3. 遥控传递：允许在系统内传递遥控器指令到另一个设备。

*是否支持 HDMI-CEC 通常可选。不过，大多数制造商都已采用 HDMI-CEC，因此它们的设备能够与其他公司的设备配合使用。各个制造商实现 HDMI-CEC 标准的方式不同，因此设备之间并不总是可以实现顺畅协作，而且支持的功能也因设备而异。由于存在这种差异，消费者并不能放心地假定两个声称支持 CEC 的产品是完全兼容的。*

### 标准安卓的CEC技术实现

![Untitled](%E5%AE%89%E5%8D%93HDMI%20CEC%E9%80%90%E5%B1%82%E6%A2%B3%E7%90%86%208a85a9c2d0264f9fa64d1ff8a7bba967/Untitled.png)

• 管理器类 `HdmiControlManager` 向特权应用提供 API。TV Input Manager 服务和音频服务等系统服务可以直接使用该服务。

• HDMI-CEC 通过硬件抽象层 (HAL) 与硬件连接，以简化对设备之间协议和信号传输机制的差异的处理。设备制造商可以利用 HAL 定义来实现 HAL 层。

为了让HdmiControlService正常工作，需要做以下设置：

1. 在mk文件中加上以下配置device/company/common/products/tv/company_tv.mk
    
    ```xml
    PRODUCT_COPY_FILES += \
     frameworks/native/data/etc/android.hardware.hdmi.cec.xml:$(TARGET_COPY_OUT_VENDOR)/etc/permissions/android.hardware.hdmi.cec.xml
    ```
    
2. OTT 服务 (OTT) 或机顶盒 (STB) 设备等 HDMI 源设备：`PRODUCT_PROPERTY_OVERRIDES += ro.hdmi.device_type=4`
3. 对于平板电视等 HDMI 接收设备：`PRODUCT_PROPERTY_OVERRIDES += ro.hdmi.device_type=0`

**逐层梳理代码逻辑**

- 在Java Framework中`HdmiControlService`
负责了HDMI-CEC几乎所有的功能。HdmiControlService作为一个系统服务被启动。应用层所有的关于CEC的操作都通过HdmiControlService间接实现。
    
    ```java
    boolean connectToHal() {
                try {
                    //获取HDMI-CEC的实现
                    mHdmiCec = IHdmiCec.getService();
                    try {
                        mHdmiCec.linkToDeath(this, HDMI_CEC_HAL_DEATH_COOKIE);
                    } catch (RemoteException e) {
                        HdmiLogger.error("Couldn't link to death : ", e);
                    }
                } catch (RemoteException e) {
                    HdmiLogger.error("Couldn't get tv.cec service : ", e);
                    return false;
                }
                return true;
            }
    ```
    
- HdmiControlService代码中调用了IHdmiCec。IHdmiCec是一个hidl接口，所有与cec hal层的交互都是通过这个接口实现
    
    hal层主要实现函数如下：
    
    ```c
    struct HdmiCec : public IHdmiCec, public hidl_death_recipient {
        HdmiCec(hdmi_cec_device_t* device);
        // Methods from ::android::hardware::tv::cec::V1_0::IHdmiCec follow.
        Return<Result> addLogicalAddress(CecLogicalAddress addr)  override;
        Return<void> clearLogicalAddress()  override;
        Return<void> getPhysicalAddress(getPhysicalAddress_cb _hidl_cb)  override;
        Return<SendMessageResult> sendMessage(const CecMessage& message)  override;
        Return<void> setCallback(const sp<IHdmiCecCallback>& callback)  override;
        Return<int32_t> getCecVersion()  override;
        Return<uint32_t> getVendorId()  override;
        Return<void> getPortInfo(getPortInfo_cb _hidl_cb)  override;
        Return<void> setOption(OptionKey key, bool value)  override;
        Return<void> setLanguage(const hidl_string& language)  override;
        Return<void> enableAudioReturnChannel(int32_t portId, bool enable)  override;
        Return<bool> isConnected(int32_t portId)  override;
    
        static void eventCallback(const hdmi_event_t* event, void* /* arg */) {
            if (mCallback != nullptr && event != nullptr) {
                if (event->type == HDMI_EVENT_CEC_MESSAGE) {
                    size_t length = std::min(event->cec.length,
                            static_cast<size_t>(MaxLength::MESSAGE_BODY));
                    CecMessage cecMessage {
                        .initiator = static_cast<CecLogicalAddress>(event->cec.initiator),
                        .destination = static_cast<CecLogicalAddress>(event->cec.destination),
                    };
                    cecMessage.body.resize(length);
                    for (size_t i = 0; i < length; ++i) {
                        cecMessage.body[i] = static_cast<uint8_t>(event->cec.body[i]);
                    }
                    mCallback->onCecMessage(cecMessage);
                } else if (event->type == HDMI_EVENT_HOT_PLUG) {
                    HotplugEvent hotplugEvent {
                        .connected = event->hotplug.connected > 0,
                        .portId = static_cast<uint32_t>(event->hotplug.port_id)
                    };
                    mCallback->onHotplugEvent(hotplugEvent);
                }
            }
        }
       virtual void serviceDied(uint64_t /*cookie*/,
                                 const wp<::android::hidl::base::V1_0::IBase>& /*who*/) {
            setCallback(nullptr);
        }
    
       private:
        static sp<IHdmiCecCallback> mCallback;
        const hdmi_cec_device_t* mDevice;
    };
    ```
    
    以上函数主要功能包括：
    1. 配置 HAL 数据（地址、功能）。
    2. 发送 HDMI-CEC 命令。
    3. 注册回调以接收 HDMI-CEC 命令和热插拔事件。
    

### TCL的cec代码结构

tcl厂商修改在 vendor/tcl/tif/hdmi_cec中

其头文件位置在 ./vendor/tcl/tif/sitainclude/tcl_hdmi_cec.h

其通过 hw_module_t 调用底层接口

hal层位置在 hardware/interfaces/tv/cec

底层驱动代码位于 vendor/amlogic/tv/tvhal/core/aml_hal_core_hdmicec.cpp

```cpp
int sendMessage(unsigned char *buf, int msgLength)
{
    if (mCecDevice->mFd < 0)
        return -1;
    unsigned char msgBuf[CEC_MESSAGE_BODY_MAX_LENGTH];
    int ret = -1;
    memset(msgBuf, 0, sizeof(msgBuf));
    memcpy(msgBuf, buf, msgLength);
    ret = write(mCecDevice->mFd, msgBuf, msgLength);
    return ret;
}
```

## 标准CEC协议命令

```c
enum cec_message_type {
    CEC_MESSAGE_FEATURE_ABORT = 0x00,
    CEC_MESSAGE_IMAGE_VIEW_ON = 0x04,
    CEC_MESSAGE_TUNER_STEP_INCREMENT = 0x05,
    CEC_MESSAGE_TUNER_STEP_DECREMENT = 0x06,
    CEC_MESSAGE_TUNER_DEVICE_STATUS = 0x07,
    CEC_MESSAGE_GIVE_TUNER_DEVICE_STATUS = 0x08,
    CEC_MESSAGE_RECORD_ON = 0x09,
    CEC_MESSAGE_RECORD_STATUS = 0x0A,
    CEC_MESSAGE_RECORD_OFF = 0x0B,
    CEC_MESSAGE_TEXT_VIEW_ON = 0x0D,
    CEC_MESSAGE_RECORD_TV_SCREEN = 0x0F,
    CEC_MESSAGE_GIVE_DECK_STATUS = 0x1A,
    CEC_MESSAGE_DECK_STATUS = 0x1B,
    CEC_MESSAGE_SET_MENU_LANGUAGE = 0x32,
    CEC_MESSAGE_CLEAR_ANALOG_TIMER = 0x33,
    CEC_MESSAGE_SET_ANALOG_TIMER = 0x34,
    CEC_MESSAGE_TIMER_STATUS = 0x35,
    CEC_MESSAGE_STANDBY = 0x36,
    CEC_MESSAGE_PLAY = 0x41,
    CEC_MESSAGE_DECK_CONTROL = 0x42,
    CEC_MESSAGE_TIMER_CLEARED_STATUS = 0x043,
    CEC_MESSAGE_USER_CONTROL_PRESSED = 0x44,
    CEC_MESSAGE_USER_CONTROL_RELEASED = 0x45,
    CEC_MESSAGE_GIVE_OSD_NAME = 0x46,
    CEC_MESSAGE_SET_OSD_NAME = 0x47,
    CEC_MESSAGE_SET_OSD_STRING = 0x64,
    CEC_MESSAGE_SET_TIMER_PROGRAM_TITLE = 0x67,
    CEC_MESSAGE_SYSTEM_AUDIO_MODE_REQUEST = 0x70,
    CEC_MESSAGE_GIVE_AUDIO_STATUS = 0x71,
    CEC_MESSAGE_SET_SYSTEM_AUDIO_MODE = 0x72,
    CEC_MESSAGE_REPORT_AUDIO_STATUS = 0x7A,
    CEC_MESSAGE_GIVE_SYSTEM_AUDIO_MODE_STATUS = 0x7D,
    CEC_MESSAGE_SYSTEM_AUDIO_MODE_STATUS = 0x7E,
    CEC_MESSAGE_ROUTING_CHANGE = 0x80,
    CEC_MESSAGE_ROUTING_INFORMATION = 0x81,
    CEC_MESSAGE_ACTIVE_SOURCE = 0x82,
    CEC_MESSAGE_GIVE_PHYSICAL_ADDRESS = 0x83,
    CEC_MESSAGE_REPORT_PHYSICAL_ADDRESS = 0x84,
    CEC_MESSAGE_REQUEST_ACTIVE_SOURCE = 0x85,
    CEC_MESSAGE_SET_STREAM_PATH = 0x86,
    CEC_MESSAGE_DEVICE_VENDOR_ID = 0x87,
    CEC_MESSAGE_VENDOR_COMMAND = 0x89,
    CEC_MESSAGE_VENDOR_REMOTE_BUTTON_DOWN = 0x8A,
    CEC_MESSAGE_VENDOR_REMOTE_BUTTON_UP = 0x8B,
    CEC_MESSAGE_GIVE_DEVICE_VENDOR_ID = 0x8C,
    CEC_MESSAGE_MENU_REQUEST = 0x8D,
    CEC_MESSAGE_MENU_STATUS = 0x8E,
    CEC_MESSAGE_GIVE_DEVICE_POWER_STATUS = 0x8F,
    CEC_MESSAGE_REPORT_POWER_STATUS = 0x90,
    CEC_MESSAGE_GET_MENU_LANGUAGE = 0x91,
    CEC_MESSAGE_SELECT_ANALOG_SERVICE = 0x92,
    CEC_MESSAGE_SELECT_DIGITAL_SERVICE = 0x93,
    CEC_MESSAGE_SET_DIGITAL_TIMER = 0x97,
    CEC_MESSAGE_CLEAR_DIGITAL_TIMER = 0x99,
    CEC_MESSAGE_SET_AUDIO_RATE = 0x9A,
    CEC_MESSAGE_INACTIVE_SOURCE = 0x9D,
    CEC_MESSAGE_CEC_VERSION = 0x9E,
    CEC_MESSAGE_GET_CEC_VERSION = 0x9F,
    CEC_MESSAGE_VENDOR_COMMAND_WITH_ID = 0xA0,
    CEC_MESSAGE_CLEAR_EXTERNAL_TIMER = 0xA1,
    CEC_MESSAGE_SET_EXTERNAL_TIMER = 0xA2,
    CEC_MESSAGE_INITIATE_ARC = 0xC0,
    CEC_MESSAGE_REPORT_ARC_INITIATED = 0xC1,
    CEC_MESSAGE_REPORT_ARC_TERMINATED = 0xC2,
    CEC_MESSAGE_REQUEST_ARC_INITIATION = 0xC3,
    CEC_MESSAGE_REQUEST_ARC_TERMINATION = 0xC4,
    CEC_MESSAGE_TERMINATE_ARC = 0xC5,
    CEC_MESSAGE_ABORT = 0xFF
};
```

### 关机联动相关修改

framework/base/cmd 下修改设置应用关机联动逻辑

```diff
--- a/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java
+++ b/services/core/java/com/android/server/hdmi/HdmiCecLocalDevice.java
@@ -36,6 +36,8 @@ import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 
+import android.provider.Settings.Global;
+
 /**
  * Class that models a logical CEC device hosted in this system. Handles initialization,
  * CEC commands that call for actions customized per device type.
@@ -446,7 +448,9 @@ abstract class HdmiCecLocalDevice {
         // Seq #12
         if (mService.isControlEnabled() && !mService.isProhibitMode()
                 && mService.isPowerOnOrTransient()) {
-            mService.standby();
+               boolean isAutoPowerOff= mService.readBooleanSetting(Global.HDMI_CONTROL_AUTO_DEVICE_OFF_ENABLED, true);
+               if(isAutoPowerOff)            
+                       mService.standby();
             return true;
         }
         return false;
```

vendor/tcl/tif/hdmi_cec中去除0x36条件判断